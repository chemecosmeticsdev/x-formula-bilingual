const AWS = require('aws-sdk');

// Configure AWS SDK - use IAM role credentials automatically
const bedrock = new AWS.BedrockRuntime({
  region: 'us-east-1'
});

const s3 = new AWS.S3({
  region: 'us-east-1'
});

exports.handler = async (event) => {
  console.log('Image generation Lambda called with event:', JSON.stringify(event, null, 2));

  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
    'Content-Type': 'application/json'
  };

  // Handle preflight requests
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({ message: 'CORS preflight successful' })
    };
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: 'Method not allowed' })
    };
  }

  try {
    // Parse request body
    const body = typeof event.body === 'string' ? JSON.parse(event.body) : event.body;
    const { prompt, model, width, height, quality, cfg_scale, seed } = body;

    if (!prompt) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: 'Prompt is required' })
      };
    }

    console.log(`Generating image with model: ${model || 'amazon.nova-canvas-v1:0'}`);
    console.log('Prompt preview:', prompt.substring(0, 200) + '...');

    // Determine which model to use
    const selectedModel = model || 'amazon.nova-canvas-v1:0';
    let modelBody;
    let responseImageKey;

    if (selectedModel.includes('nova-canvas')) {
      // Nova Canvas parameters
      modelBody = {
        taskType: "TEXT_IMAGE",
        textToImageParams: {
          text: prompt
        },
        imageGenerationConfig: {
          numberOfImages: 1,
          height: height || 1024,
          width: width || 1024,
          cfgScale: cfg_scale || 8.0,
          seed: seed || Math.floor(Math.random() * 1000000)
        }
      };
      responseImageKey = 'images';
    } else if (selectedModel.includes('titan-image')) {
      // Titan Image Generator parameters
      modelBody = {
        taskType: "TEXT_IMAGE",
        textToImageParams: {
          text: prompt
        },
        imageGenerationConfig: {
          numberOfImages: 1,
          quality: quality || "premium",
          height: height || 1024,
          width: width || 1024,
          cfgScale: cfg_scale || 8.0,
          seed: seed || Math.floor(Math.random() * 1000000)
        }
      };
      responseImageKey = 'images';
    } else {
      throw new Error(`Unsupported model: ${selectedModel}`);
    }

    // Call AWS Bedrock
    console.log('Calling AWS Bedrock with model:', selectedModel);
    const bedrockParams = {
      modelId: selectedModel,
      contentType: 'application/json',
      accept: 'application/json',
      body: JSON.stringify(modelBody)
    };

    const bedrockResponse = await bedrock.invokeModel(bedrockParams).promise();
    const responseBody = JSON.parse(bedrockResponse.body.toString());

    console.log('Bedrock response received');

    if (!responseBody[responseImageKey] || !responseBody[responseImageKey][0]) {
      throw new Error('No images generated by Bedrock');
    }

    // Extract base64 image data
    const imageBase64 = responseBody[responseImageKey][0];
    const imageBuffer = Buffer.from(imageBase64, 'base64');

    // Upload to S3 with unique filename
    const timestamp = Date.now();
    const bucketName = process.env.S3_BUCKET || 'formula-platform-images';
    const s3Key = `generated-images/${timestamp}-packaging-mockup.png`;

    console.log('Uploading image to S3:', s3Key);

    const uploadParams = {
      Bucket: bucketName,
      Key: s3Key,
      Body: imageBuffer,
      ContentType: 'image/png',
      Metadata: {
        'generated-by': 'aws-bedrock',
        'model': selectedModel,
        'timestamp': timestamp.toString()
      }
    };

    const uploadResult = await s3.upload(uploadParams).promise();
    console.log('Image uploaded successfully:', uploadResult.Location);

    // Generate presigned URL for temporary access (optional, since we're using public-read)
    const presignedUrl = s3.getSignedUrl('getObject', {
      Bucket: bucketName,
      Key: s3Key,
      Expires: 3600 // 1 hour
    });

    const response = {
      success: true,
      imageUrl: uploadResult.Location,
      s3_url: uploadResult.Location,
      presigned_url: presignedUrl,
      metadata: {
        model: selectedModel,
        dimensions: `${width || 1024}x${height || 1024}`,
        generated_at: new Date().toISOString(),
        s3_key: s3Key
      }
    };

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(response)
    };

  } catch (error) {
    console.error('Image generation error:', error);

    // Return detailed error for debugging
    const errorResponse = {
      success: false,
      error: error.message,
      errorType: error.name,
      timestamp: new Date().toISOString()
    };

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify(errorResponse)
    };
  }
};